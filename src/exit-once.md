# Виходьте один раз

Якщо можливо, надайте перевагу виклику `os.Exit` або `log.Fatal` **не більше одного разу**
у вашій функції `main()`. Якщо існує кілька сценаріїв помилок, які зупиняють виконання програми,
помістіть цю логіку в окрему функцію та вже з неї повертайте помилки.

Це призводить до скорочення вашої функції `main()` та тримає всю ключову бізнес-логіку
в окремій функції, яку можна протестувати.

<table>
<thead><tr><th>Не рекомендовано</th><th>Рекомендовано</th></tr></thead>
<tbody>
<tr><td>

```go
package main

func main() {
  args := os.Args[1:]
  if len(args) != 1 {
    log.Fatal("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

  // Якщо ми викличемо log.Fatal після цього рядка,
  // f.Close не буде викликано.

  b, err := io.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }

  // ...
}
```

</td><td>

```go
package main

func main() {
  if err := run(); err != nil {
    log.Fatal(err)
  }
}

func run() error {
  args := os.Args[1:]
  if len(args) != 1 {
    return errors.New("missing file")
  }
  name := args[0]

  f, err := os.Open(name)
  if err != nil {
    return err
  }
  defer f.Close()

  b, err := io.ReadAll(f)
  if err != nil {
    return err
  }

  // ...
}
```

</td></tr>
</tbody></table>

У наведеному вище прикладі використовується `log.Fatal`, але настанови також стосуються `os.Exit` або будь-якого бібліотечного коду, який викликає `os.Exit`.

```go
func main() {
  if err := run(); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

Ви можете змінити сигнатуру `run()` відповідно до ваших потреб.
Наприклад, якщо ваша програма має завершувати роботу з певним кодом завершення у випадку помилок, `run()` може повертати код завершення замість помилки. Це дозволить модульним тестам безпосередньо перевіряти таку поведінку.

```go
func main() {
  os.Exit(run(args))
}

func run() (exitCode int) {
  // ...
}
```

Загалом, зауважте, що функція `run()`, яка використовується у цих прикладах, не є директивною. Існує гнучкість у назві, сигнатурі та налаштуванні функції `run()`. Серед іншого, ви можете:

- прийняти необроблені аргументи командного рядка (наприклад, `run(os.Args[1:])`)
- розібрати аргументи командного рядка в `main()` та передати їх до функції `run`.
- використовувати спеціальний тип помилки для передачі коду завершення роботи назад в `main()`
- винести бізнес-логіку на інший рівень абстракції, ніж `package main`.

Ці настанови вимагають, щоб у вашому `main()` було єдине місце, яке відповідає за фактичний вихід з процесу.
