# Одержувачі (receivers) та інтерфейси

Методи з одержувачами за значенням, можуть бути викликані як за вказівниками, так і за значеннями.
Методи з одержувачами вказівника, можуть бути викликані лише через вказівник або [адресовані значення].

  [адресовані значення]: https://golang.org/ref/spec#Method_values

Наприклад,


```go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

// Ми не можемо отримати вказівники на значення, що зберігаються в картах,
// тому що вони не є адресованими значеннями.
sVals := map[int]S{1: {"A"}}

// Ми можемо викликати Read для значень, що зберігаються у карті,
// оскільки Read має отримувач значення, який не вимагає,
// щоб значення було адресованим.
sVals[1].Read()

// Ми не можемо викликати Write для значень, що зберігаються у карті,
// оскільки Write має отримувач вказівника, а отримати вказівник на
// значення, що зберігається у карті, неможливо.
//
//  sVals[1].Write("test")

sPtrs := map[int]*S{1: {"A"}}

// Ви можете викликати читання і запис, якщо карта зберігає вказівники, 
// оскільки вказівники є адресованими за своєю суттю.
sPtrs[1].Read()
sPtrs[1].Write("test")
```

Подібним чином інтерфейс може бути реалізований як вказівник, навіть якщо одержувач методу переданий як значення.

```go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

s1Val := S1{}
s1Ptr := &S1{}
s2Val := S2{}
s2Ptr := &S2{}

var i F
i = s1Val
i = s1Ptr
i = s2Ptr

// Наступний код не скомпілюється, оскільки s2Val є значенням, а для f не існує отримувача значення.
//   i = s2Val
```

Effective Go чудово описує [вказівники або значення].

  [вказівники або значення]: https://golang.org/doc/effective_go.html#pointers_vs_values
