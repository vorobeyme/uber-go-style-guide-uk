# Вбудовування в структури

Вбудовані типи повинні бути у верхній частині списку полів структури,
також повинен бути порожній рядок, який відокремлює вбудовані поля від звичайних полів.

<table>
<thead><tr><th>Не рекомендовано</th><th>Рекомендовано</th></tr></thead>
<tbody>
<tr><td>

```go
type Client struct {
  version int
  http.Client
}
```

</td><td>

```go
type Client struct {
  http.Client

  version int
}
```

</td></tr>
</tbody></table>

Вбудовування має забезпечувати відчутні переваги, як-от додавання або розширення функціональності
семантично прийнятним способом. Це повинно робитись без негативних наслідків для користувача
(див. також: [уникайте вбудовування типів у публічні структури](embed-public.md)).

Виняток: м'ютекси не можна вбудовувати, навіть у не експортовані типи (див. [дозволене використання м'ютексів з нульовими значеннями](mutex-zero-value.md)).

Вбудовування **не повинно**:

- Бути суто косметичними або орієнтованими лише на зручність.
- Робити зовнішні типи більш складними для створення або використання.
- Впливати на нульові значення зовнішніх типів.
  Якщо зовнішній тип має корисне нульове значення, то вбудовування внутрішнього типу не повинно
  це змінити.
- Робити публічними функції або поля внутрішнього типу, які жодним чином не пов'язані із зовнішнім типом.
- Розкривати не експортовані типи.
- Впливати на семантику копіювання зовнішніх типів.
- Змінювати API або семантику зовнішнього типу.
- Вставляти неканонічну форму внутрішнього типу.
- Розкривати деталі реалізації зовнішнього типу.
- Дозволяти користувачам спостерігати або контролювати внутрішні елементи.
- Змінювати загальну поведінку внутрішніх функцій, обгорнувши неочікуваними для користувача способами.


Простіше кажучи, робіть вбудовування свідомо та цілеспрямовано.
Хорошим лакмусовим папірцем є запитати себе:
"чи всі ці експортовані внутрішні методи/поля будуть додані безпосередньо до зовнішнього типу?";
якщо відповідь "деякі" або "ні", не вставляйте внутрішній тип, замість цього використовуйте поле.

<table>
<thead><tr><th>Не рекомендовано</th><th>Рекомендовано</th></tr></thead>
<tbody>
<tr><td>

```go
type A struct {
    // Погано: A.Lock() і A.Unlock() тепер доступні,
    //         не забезпечують жодних функціональних переваг
    //         і дозволяють користувачам контролювати деталі
    //         внутрішніх елементів A.
    sync.Mutex
}
```

</td><td>

```go
type countingWriteCloser struct {
    // Добре: Write() надається на цьому зовнішньому рівні
    //        для певної мети та делегує роботу 
    //        до внутрішнього типу Write().
    io.WriteCloser

    count int
}

func (w *countingWriteCloser) Write(bs []byte) (int, error) {
    w.count += len(bs)
    return w.WriteCloser.Write(bs)
}
```

</td></tr>
<tr><td>

```go
type Book struct {
    // Погано: вказівник змінює корисне нульове значення
    io.ReadWriter

    // інші поля
}

// далі

var b Book
b.Read(...)  // panic: вказівник nil
b.String()   // panic: вказівник nil
b.Write(...) // panic: вказівник nil
```

</td><td>

```go
type Book struct {
    // Добре: має корисне нульове значення
    bytes.Buffer

    // інші поля
}

// далі

var b Book
b.Read(...)  // ok
b.String()   // ok
b.Write(...) // ok
```

</td></tr>
<tr><td>

```go
type Client struct {
    sync.Mutex
    sync.WaitGroup
    bytes.Buffer
    url.URL
}
```

</td><td>

```go
type Client struct {
    mtx sync.Mutex
    wg  sync.WaitGroup
    buf bytes.Buffer
    url url.URL
}
```

</td></tr>
</tbody></table>
