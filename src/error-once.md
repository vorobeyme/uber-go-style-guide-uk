# Обробляйте помилки один раз

Коли користувач отримує помилку, він може обробити її різними способами, залежно від того, що йому відомо про помилку.

Ці способи включають, але не обмежуються ними:

- якщо в контракті визначено специфічні помилки, зіставляйте помилку з `errors.Is` або `errors.As` і обробляйте окремо
- якщо помилку можна виправити, залогуйте її та поступово зменшіть її функціональність (degrade gracefully)
- якщо помилка являє собою умову відмови, специфічну для домену, повертати чітко визначену помилку
- повернення помилки у [обгорнутому вигляді](error-wrap.md) або повністю

Незалежно від того, як програма обробляє помилку, вона повинна обробляти кожну помилку лише один раз. Наприклад, програма не повинна логувати помилку, а потім повертати її, тому що *її* користувачі також можуть обробити помилку.

Наприклад, розглянемо наступні випадки:

<table>
<thead><tr><th>Опис</th><th>Код</th></tr></thead>
<tbody>
<tr><td>

**Не рекомендовано**: Залогувати помилку та повернути її

Виклики, що знаходяться вище у стеку, скоріш за все, виконають аналогічну дію з помилкою.
Це спричиняє багато шуму в логах програми, який не має жодної цінності.

</td><td>

```go
u, err := getUser(id)
if err != nil {
  // Погано: див. опис
  log.Printf("Could not get user %q: %v", id, err)
  return err
}
```

</td></tr>
<tr><td>

**Рекомендовано**: Обгорнути помилку і повернути її

Виклики, що знаходяться вище у стеку, оброблятимуть помилку.
Використання `%w` гарантує, що вони зможуть порівняти помилку з `errors.Is` або `errors.As`, якщо це доречно.

</td><td>

```go
u, err := getUser(id)
if err != nil {
  return fmt.Errorf("get user %q: %w", id, err)
}
```

</td></tr>
<tr><td>

**Рекомендовано**: Залогуйте помилку та поступово зменшуйте її функціональність

Якщо операція не є вкрай необхідною, ми можемо забезпечити зниження функціональності помилки, лише залогувавши її.

</td><td>

```go
if err := emitMetrics(); err != nil {
  // Відмова від запису метрик не повинна
  // порушити роботу програми.
  log.Printf("Could not emit metrics: %v", err)
}

```

</td></tr>
<tr><td>

**Рекомендовано**: Знайдіть помилку та поступово зменшуйте її функціональність

Якщо клієнт визначає конкретну помилку у своєму контракті, і цю помилку можна виправити, знайдіть її та поступово зменшуйте функціональність.
У всіх інших випадках обгорніть помилку і поверніть її.

Інші помилки оброблятимуться учасниками, які знаходяться вище в стеку.

</td><td>

```go
tz, err := getUserTimeZone(id)
if err != nil {
  if errors.Is(err, ErrUserNotFound) {
    // Користувач не існує. Використовуйте UTC.
    tz = time.UTC
  } else {
    return fmt.Errorf("get user %q: %w", id, err)
  }
}
```

</td></tr>
</tbody></table>
