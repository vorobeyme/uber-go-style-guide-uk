# Уникайте вбудовування типів (type embedding) у публічні структури

Типи, вбудовані в публічні структури, пропускають деталі реалізації,
обмежують розвиток типів і негативно впливають на якість документації.

Якщо припустити, що ви реалізували різні типи списків за допомогою спільного
`AbstractList`, уникайте вбудовування `AbstractList` у ваші конкретні реалізації списків.
Натомість, додайте до свого конкретного списку методи, які будуть делегувати
завдання методам абстрактного списку `AbstractList`.

```go
type AbstractList struct {}

// Add додає сутність до списку.
func (l *AbstractList) Add(e Entity) {
  // ...
}

// Remove видаляє сутність зі списку.
func (l *AbstractList) Remove(e Entity) {
  // ...
}
```

<table>
<thead><tr><th>Не рекомендовано</th><th>Рекомендовано</th></tr></thead>
<tbody>
<tr><td>

```go
// ConcreteList - список сутностей.
type ConcreteList struct {
  *AbstractList
}
```

</td><td>

```go
// ConcreteList - список сутностей.
type ConcreteList struct {
  list *AbstractList
}

// Add додає сутність до списку.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove видаляє сутність зі списку.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Go дозволяє [вбудовування типу] як компроміс між наслідуванням та композицією.
Зовнішній тип отримує неявні копії методів вбудованого типу.
За замовчуванням, ці методи делегують завдання методам вбудованого екземпляра.

  [вбудовування типу]: https://golang.org/doc/effective_go.html#embedding

Структура також отримує поле з тим же іменем, що й тип.
Отже, якщо вбудований тип загальнодоступний, поле також буде публічним.
Для зворотної сумісності, будь-яка майбутня версія зовнішнього типу
повинна зберігати вбудований тип.

Вбудований тип рідко буває необхідним.
В основному це зручний спосіб уникнути виснажливого написання методів делегування.

Навіть вбудовування сумісного *інтерфейсу* AbstractList замість структури,
надасть розробнику більше гнучкості для внесення змін в майбутньому,
але все одно призведе до витоку інформації про те, що конкретні списки
використовують абстрактну реалізацію.

<table>
<thead><tr><th>Не рекомендовано</th><th>Рекомендовано</th></tr></thead>
<tbody>
<tr><td>

```go
// AbstractList — це узагальнена реалізація для різних
// видів списків сутностей.
type AbstractList interface {
  Add(Entity)
  Remove(Entity)
}

// ConcreteList — це список сутностей.
type ConcreteList struct {
  AbstractList
}
```

</td><td>

```go
// ConcreteList — це список сутностей.
type ConcreteList struct {
  list AbstractList
}

// Add додає сутність до списку.
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}

// Remove видаляє сутність зі списку.
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
```

</td></tr>
</tbody></table>

Чи це вбудована структура, чи вбудований інтерфейс, вбудований тип обмежує розвиток цього типу.

- Додавання методів до вбудованого інтерфейсу порушує сумісність (breaking changes).
- Видалення методів із вбудованої структури порушує сумісність.
- Видалення вбудованого типу порушує сумісність.
- Заміна вбудованого типу, навіть якщо заміна відповідає тому самому інтерфейсу,
  порушує сумісність.

Попри те, що написання цих методів делегування (методи, визначені в інтерфейсі) є громіздким,
додаткові зусилля приховують деталі реалізації, залишають більше можливостей для змін,
а також усувають непрямий доступ до повного інтерфейсу List в документації.
