# Обгортання помилок (wrapping)

Існує три основні способи поширення помилок у разі невдачі під час виклику:

- повернути оригінальну помилку "як є"
- додати контекст за допомогою `fmt.Errorf` та параметру `%w`
- додати контекст за допомогою `fmt.Errorf` та параметру `%v`

Повернути оригінальну помилку "як є", якщо вам не потрібно додавати додаткову контекстну інформацію.
Це зберігає вихідний тип помилки та повідомлення.
Це добре підходить для випадків, коли базове повідомлення про помилку містить
достатньо інформації, щоб визначити, звідки вона походить.

В іншому випадку додайте контекст до повідомлення про помилку, де це можливо,
щоб замість не зрозумілої помилки, як-от "підключення відмовлено", ви отримували
більш корисні помилки, наприклад "виклик служби foo: підключення відмовлено".

Використовуйте `fmt.Errorf`, щоб додати контекст до ваших помилок, вибираючи між параметрами
`%w` або `%v` залежно від того, чи повинен коистувач мати можливість знайти та виділити основну причину.

- Використовуйте `%w`, якщо користувач повинен мати доступ до основної помилки.
  Це хороший варіант за замовчуванням для більшості обгорнутих помилок,
  але пам'ятайте, що користувачі можуть почати покладатися на таку поведінку.
  Тож у випадках, коли обгорнута помилка є відомою `зміною` або `типом`,
  задокументуйте та протестуйте її як частину контракту вашої функції.
- Використовуйте `%v` для приховування основної помилки.
  Користувачі не зможуть порівнювати з оригінальною помилкою, але ви можете перемикнутися
  на `%w` в майбутньому, якщо це буде потрібно.

Додаючи контекст до помилок, зберігайте його лаконічним, уникаючи таких фраз,
як "не вдалося" ("failed to"), які стверджують очевидне та накопичуються,
коли помилка просочується крізь стек:

<table>
<thead><tr><th>Не рекомендовано</th><th>Рекомендовано</th></tr></thead>
<tbody>
<tr><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "failed to create new store: %w", err)
}
```

</td><td>

```go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        "new store: %w", err)
}
```

</td></tr><tr><td>

```plain
failed to x: failed to y: failed to create new store: the error
```

</td><td>

```plain
x: y: new store: the error
```

</td></tr>
</tbody></table>

Однак після надсилання повідомлення про помилку в іншу систему має бути зрозуміло,
що повідомлення є помилкою (наприклад, тег `err` або префікс "Failed" в журналах).

Дивіться також публікацію [не просто перевіряйте помилки, обробляйте їх витончено].

  [не просто перевіряйте помилки, обробляйте їх витончено]: https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully